E-MailRelay Internals
=====================

Module structure
----------------
There are four main C++ libraries in the E-MailRelay code: "glib" provides
low-level classes for file-system abstraction, date and time representation,
string utility functions, logging, command line parsing etc., "gnet" provides
network classes using the Berkley socket and Winsock APIs, "gsmtp" contains SMTP
and message-store classes, and "gpop" contains POP3 classes. All four libraries
are portable between POSIX-like systems (eg. Linux) and Windows.

Under Windows there is an additional library for event handling. Windows has
historically built network event processing on top of the GUI event system which
means that the "gnet" library has to be able to create GUI windows in order to
process network events. The extra GUI and event classes are put into a separate
library in the "src/win32" directory, using the namespace "GGui".

Core class structure
--------------------
The message-store functionality uses three abstract interfaces: "MessageStore",
"NewMessage" and "StoredMessage". The "NewMessage" interface is used to create
messages within the store, and the "StoredMessage" interface is used for
reading and extracting messages from the store. The concrete implementation
classes based on these interfaces are respectively "FileStore", "NewFile" and
"StoredFile".

The interaction between the server protocol class and the message store is
mediated by the "ProtocolMessage" interface. Two main implementations of this
interface are supplied: one for normal spooling ("ProtocolMessageStore"), and
another for immediate forwarding ("ProtocolMessageForward").

The protocol and message-store functionality are brought together by the
high-level "GSmtp::Server" and "GSmtp::Client" classes.

Simplified class diagrams for the *GNet* [gnet-classes.png] and
*GSmtp* [gsmtp-classes.png] namespaces are available.

Event model
-----------
The E-MailRelay server uses non-blocking socket i/o, with a select() event loop.
This event model means that the server can handle multiple clients
simultaneously from a single thread and the only significant blocking occurs
when external programs are executed (see "--filter" and "--verifier").

See *C10K Problem* [http://www.kegel.com/c10k.html] for a discussion of
different network event models.

At higher levels the slot/signal design pattern is used to propagate events
between objects. (This C++ pattern should not be confused with operating
system signals.)

Event handling and exceptions
-----------------------------
The use of non-blocking i/o in the low-level "gnet" network library means
that most processing operates within the context of an i/o or timeout callback.
The top level of the call stack is therefore nearly always the event loop
code and this can make using exceptions a bit awkward because it is not
possible to put a single catch block around a given high-level feature.

The approach taken is to have all i/o events delivered to an abstract EventHandler
interface, and all timeout events delivered to the AbstractTimer interface.
The event loop code calls these interfaces to deliver events to the application
code. If these callbacks throw exceptions then the event loop will catch them
and deliver them back to the same interface through the virtual functions
onException() and onTimerException() respectively. If exceptions are thrown
out of these callbacks then the event loop code lets them propagate back
to main(), typically terminating the program.

This approach is extended slightly by having a Timer class that requires an
EventHandler object to be associated with each Timer. The Timer class routes all
exceptions thrown out of the timeout callback to the designated EventHandler
interface. This means that both i/o and timeout exceptions are delivered to the
same place.

In common with other event-driven frameworks this leads to a programming
model where objects are instantiated on the heap and the objects delete
themselves when they receive certain events from the framework. In the
"gnet" library the ServerPeer and HeapClient classes embody this lifetime
management. Instances of these classes delete themselves when the associated
network connection goes away or when an exception is thrown out their
event-handling code.

A significant disadvantage is that all exceptions are delivered using a base 
class exception type. This means that all exceptions from asynchronous code have
to be handled in the same way, typically by deleting the object associated with
the connection or terminating the event loop, leaving non-fatal errors to be 
propagated through the mainline code.

Protocol implementation
-----------------------
The SMTP and POP protocols are implemented using finite state machines. This
fits well with the single-threaded, non-blocking event model since the protocol
state can be stored as data within an object rather than being implicit in the
progress of a thread's execution.

Windows service
---------------
To get E-MailRelay to run as a Windows service there is a service wrapper
program called "emailrelay-service.exe". This program registers itself as
a service when run with the "--install" commandline switch. When the service
runs the wrapper starts the actual E-MailRelay server by looking for a batch
file called "emailrelay-start.bat" in the same directory as service wrapper
executable. It reads the contents of this batch file in order to construct the
E-MailRelay command-line, adding "--no-daemon" and "--hidden" switches if they
are not there. The service name and display name can be put onto the
wrapper's "--install" command-line, and it is the service name that is used to
derive the name of the "start" batch file.

Diagrams
--------
Class diagrams:
* *GNet namespace* [gnet-classes.png]
* *GSmtp namespace* [gsmtp-classes.png]

State transition diagrams:
* *GNet::Client* [gnet-client.png]
* *GSmtp::ServerProtocol* [gsmtp-serverprotocol.png]
* *GSmtp::ScannerClient* [gsmtp-scannerclient.png]

Sequence diagrams:
* *Proxy mode forwarding* [sequence-3.png]
* *Scanning* [sequence-4.png]
* ProtocolMessage::prepare() *returns false* [sequence-1.png]
* ProtocolMessage::prepare() *returns true* [sequence-2.png]

Directory structure
-------------------

# src

  Parent directory for source code.

# src/glib

  A low-level class library, including classes for file-system abstraction,
  date and time, string utility functions, logging, command line parsing etc.

# src/gnet

  A network library using Berkley sockets or Winsock.

# src/gsmtp

  An SMTP library.

# src/gpop

  A POP3 library.

# src/win32

  Additional classes for windows event processing.

# src/main

  Application-level classes for E-MailRelay.

# lib

  Parent directory for ANSI C++ fixes

# lib/gcc2.95

  Standard headers which are missing in gcc2.95

# lib/msvc6.0

  Standard headers which are missing (or broken) in msvc6.0

Portability
-----------
The E-MailRelay code is written in ISO C++, although avoiding less-widely
supported language features like "mutable", templated methods and "export".

The header files "gdef.h" in "src/glib", and "gnet.h" in "src/gnet" are intended
to be used to fix up compiler portability issues such as missing standard types,
non-standard system headers etc. Conditional compilation directives ("#if"
etc.) are largely confined to these headers in order to improve readability.

Deficiencies in the ISO standard headers files provided by the compiler are
fixed up by files in the "lib" directory tree. For example, the msvc6.0 compiler
sometimes does not put its names into the "std" namespace, even though the
std-namespace headers are used. This can be worked round by additional "using"
declarations in the "lib/msvc6.0" headers.  These work-rounds are kept out of
the "src" tree because they are likely to be fixed in later compiler releases.
Standards-compliant compilers should not need to include any headers from the
"lib" directory tree.

Windows/unix portability is generally addressed by providing a common class
declaration with two implementations. Where necessary a "pimple" pattern is used
to hide the system-specific parts of the declaration.

A good example is the "G::Directory" class used for iterating through files in
a directory. The header file "src/glib/gdirectory.h" is common to both systems,
but two implementations are provided in "gdirectory_unix.cpp" and
"gdirectory_win32.cpp". The unix implementation uses opendir() and glob(),
while the windows implementation uses FindFirstFile().

Sometimes only small parts of the implementation are system-specific. In
these cases there are three source files per header. For example, "gsocket.cpp",
"gsocket_win32.cpp" and "gsocket_unix.cpp" in the "src/gnet" directory.

Compile-time features
---------------------
Compile-time features can normally be selected with switches passed to the
"configure" script. These include the following:

* Debug-level logging ("--enable-debug")
* IPv6 (Linux only) ("--enable-ipv6")
* Configuration GUI ("--enable-gui")

Use "./configure --help" to see a complete list.

Patterns
--------
Gang-of-four Design Patterns (ISBN 0-201-63361-2):

+ Factory method

  - GNet::EventLoop::create()
  - GNet::Server::newPeer()
  - GSmtp::MessageStore::newMessage()

+ Iterator

  - G::DirectoryIterator
  - GNet::EventHandlerList::begin()/end()
  - GSmtp::MessageStore::iterator()

+ Singleton

  - G::LogOutput
  - GGui::ApplicationInstance
  - GNet::EventLoop

+ Facade

  - G::File
  - GNet::Address

+ Adapter/Mediator

  - GSmtp::ProtocolMessage

Lakos' Large Scale C++ Software Design patterns (ISBN 0-201-63362-0):

+ Insulation; fully insulating concrete class (Meyer's Effective C++ Item 34, pimple pattern)

  - G::DirectoryIterator
  - GNet::Address
  - GNet::Resolver
  - GSmtp::ProtocolMessage

+ Insulation; protocol class

  - GNet::EventHandler
  - GSmtp::NewMessage
  - GSmtp::StoredMessage
  - GSmtp::ProtocolMessage
  - GSmtp::ServerProtocol::Sender
  - GSmtp::ClientProtocol::Sender

Meyer's More Effective C++ patterns (ISBN 0-201-63371-X):

+ Reference counting (Item 29)

  - GSmtp::MessageStore::Iterator
  - G::Slot0

+ Lazy evaluation (Item 17)

  - GNet::EventHandlerList::list()
  - G::Date::weekday()

Other patterns:

+ Finite state machine

  - GSmtp::ServerProtocol

+ Slot/signal

  - G::Slot0
  - G::Signal0

+ Exception-safe assignment using swap

  - G::Slot0

Idioms
------
The "<<=" operator defined in "src/glib/gmemory.h" is used idiomatically
to reassign a std::auto_ptr<>.




Copyright (C) 2001-2007 Graeme Walker <graeme_walker@users.sourceforge.net>. All rights reserved.
