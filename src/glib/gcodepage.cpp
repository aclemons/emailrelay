//
// Copyright (C) 2001-2024 Graeme Walker <graeme_walker@users.sourceforge.net>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// ===
///
/// \file gcodepage.cpp
///

#include "gdef.h"
#include "gcodepage.h"
#include "gconvert.h"
#include <array>
#include <algorithm>
#include <vector>
#include <cstdint> // std::uint_least16_t

namespace G
{
	namespace CodePageImp
	{
		using value_type = std::uint_least16_t ;
		constexpr std::array<value_type,256> cp850 {{
			0x0000, 0x263A, 0x263B, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022, 0x25D8, 0x25CB, 0x25D9, 0x2642, 0x2640, 0x266A, 0x266B, 0x263C,
			0x25BA, 0x25C4, 0x2195, 0x203C, 0x00B6, 0x00A7, 0x25AC, 0x21A8, 0x2191, 0x2193, 0x2192, 0x2190, 0x221F, 0x2194, 0x25B2, 0x25BC,
			0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
			0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
			0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
			0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
			0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
			0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x2302,
			0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
			0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
			0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
			0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0, 0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
			0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
			0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x0131, 0x00CD, 0x00CE, 0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
			0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE, 0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
			0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8, 0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0,
			}} ;
		constexpr std::array<value_type,256> cp8859_15 {{
			0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
			0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
			0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
			0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
			0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
			0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
			0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
			0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
			0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x008D, 0x008E, 0x008F,
			0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F,
			0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x20AC, 0x00A5, 0x0160, 0x00A7, 0x0161, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
			0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x017D, 0x00B5, 0x00B6, 0x00B7, 0x017E, 0x00B9, 0x00BA, 0x00BB, 0x0152, 0x0153, 0x0178, 0x00BF,
			0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
			0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
			0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
			0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
			}} ;
		constexpr std::array<value_type,256> cp1252 {{
			0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
			0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
			0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
			0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
			0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
			0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
			0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
			0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
			0x20AC, 0xFFFF, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0xFFFF, 0x017D, 0xFFFF,
			0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0xFFFF, 0x017E, 0x0178,
			0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
			0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
			0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
			0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
			0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
			0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
			}} ;
		constexpr std::array<value_type,256> cp1252_bestfit {{
			0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
			0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
			0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
			0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
			0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
			0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
			0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
			0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
			0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,
			0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, 0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178,
			0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
			0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
			0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
			0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
			0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
			0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
			}} ;

		std::string fromCodePage( std::string_view , const value_type * , std::size_t , wchar_t e = L'\xFFFD' ) ;
		std::string toCodePage( std::string_view , const value_type * , std::size_t , char e ) ;
		std::string fromCodePage850( std::string_view s )  ;
		std::string toCodePage850( std::string_view s ) ;
		std::string fromCodePage1252( std::string_view s ) ;
		std::string toCodePage1252( std::string_view s ) ;
		std::string toCodePageImp( unsigned int cp , std::string_view , char e , std::string (*fallback_fn)(std::string_view) ) ;
		std::string fromCodePageImp( unsigned int cp , std::string_view , std::string (*fallback_fn)(std::string_view) ) ;

		std::size_t sizet( int i ) { return i >= 0 ? static_cast<std::size_t>(i) : std::size_t(0) ; }
		template <typename T> int isize( const T & container ) { return static_cast<int>( container.size() ) ; }
		template <typename T> typename T::value_type * dataout( T & string ) { return &string[0] ; }

		#ifdef G_UNIX
			static constexpr int CP_OEMCP = 1 ;
			static constexpr int CP_ACP = 2 ;
			static constexpr int WC_NO_BEST_FIT_CHARS = 1 ;
			inline int WideCharToMultiByte( int , int , const wchar_t * , int , char * , int , char * , bool * ) { return 0 ; }
			inline int MultiByteToWideChar( int , int , const char * , int , wchar_t * , int ) { return 0 ; }
		#endif
	}
}

std::string G::CodePageImp::fromCodePage( std::string_view sv , const value_type * map_begin ,
	std::size_t map_size , wchar_t e )
{
	std::array<char,4> u8buffer ;
	std::string result ;
	result.reserve( sv.size() * 2U ) ;
	for( char c : sv )
	{
		unsigned int uc = static_cast<unsigned char>(c) ;
		wchar_t w = uc <= map_size && map_begin[uc] != 0xFFFF ? static_cast<wchar_t>( map_begin[uc] ) : e ;
		char * u8p = u8buffer.data() ;
		auto u8n = Convert::u8out( w , u8p ) ;
		for( auto i = 0U ; i < u8n ; i++ )
			result.append( 1U , u8buffer[i] ) ;
	}
	return result ;
}

std::string G::CodePageImp::toCodePage( std::string_view sv , const value_type * map_begin ,
	std::size_t map_size , char e )
{
	std::string result ;
	result.reserve( sv.size() ) ;

	const unsigned char * p = reinterpret_cast<const unsigned char*>( sv.data() ) ;
	std::size_t n = sv.size() ;
	std::size_t d = 0U ;
	for( std::size_t i = 0U ; i < n ; i += d , p += d )
	{
		auto pair = Convert::u8in( p , n-i ) ;
		d = pair.second ;
		if( pair.first == Convert::unicode_error )
		{
			result.append( 1U , e ) ;
			d = 1U ;
		}
		else
		{
			auto const map_end = map_begin + map_size ;
			auto map_p = std::find( map_begin , map_end , static_cast<value_type>(pair.first) ) ;
			if( map_p == map_end || (*map_p) == 0xFFFF )
				result.append( 1U , e ) ;
			else
				result.append( 1U , static_cast<unsigned char>(static_cast<unsigned int>(std::distance(map_begin,map_p))) ) ;
		}
	}
	return result ;
}

std::string G::CodePage::fromCodePage850( std::string_view s )
{
	using namespace G::CodePageImp ;
	return fromCodePage( s , cp850.data() , cp850.size() ) ;
}

std::string G::CodePage::toCodePage850( std::string_view s )
{
	using namespace G::CodePageImp ;
	return toCodePage( s , cp850.data() , cp850.size() , oem_error ) ;
}

std::string G::CodePage::fromCodePage1252( std::string_view s )
{
	using namespace G::CodePageImp ;
	return fromCodePage( s , cp1252.data() , cp1252.size() ) ;
}

std::string G::CodePage::toCodePage1252( std::string_view s )
{
	using namespace G::CodePageImp ;
	return toCodePage( s , cp1252.data() , cp1252.size() , ansi_error ) ;
}

std::string G::CodePage::toCodePageOem( std::string_view s )
{
	using namespace G::CodePageImp ;
	if( s.empty() )
		return {} ;
	else if( G::is_windows() )
		return toCodePageImp( CP_OEMCP , s , oem_error , &toCodePage850 ) ;
	else
		return toCodePage850( s ) ;
}

std::string G::CodePage::toCodePageAnsi( std::string_view s )
{
	using namespace G::CodePageImp ;
	if( s.empty() )
		return {} ;
	else if( G::is_windows() )
		return toCodePageImp( CP_ACP , s , ansi_error , &toCodePage1252 ) ;
	else
		return toCodePage1252( s ) ;
}

std::string G::CodePageImp::toCodePageImp( unsigned int cp , std::string_view s , char e ,
	std::string (*fallback_fn)(std::string_view) )
{
	std::wstring ws = Convert::widen( s ) ;
	int rc1 = WideCharToMultiByte( cp , WC_NO_BEST_FIT_CHARS ,
		ws.data() , isize(ws) ,
		nullptr , 0 ,
		&e , nullptr ) ;
	if( rc1 <= 0 )
		return fallback_fn( s ) ;
	std::string buffer( sizet(rc1)+1U , '\0' ) ;
	int rc2 = WideCharToMultiByte( cp , WC_NO_BEST_FIT_CHARS ,
		ws.data() , isize(ws) ,
		dataout(buffer) , isize(buffer) ,
		&e , nullptr ) ;
	if( rc1 != rc2 )
		return fallback_fn( s ) ;
	buffer.resize( sizet(rc1) ) ;
	return buffer ;
}

std::string G::CodePage::fromCodePageOem( std::string_view s )
{
	using namespace G::CodePageImp ;
	if( s.empty() )
		return {} ;
	else if( G::is_windows() )
		return fromCodePageImp( CP_OEMCP , s , &fromCodePage850 ) ;
	else
		return fromCodePage850( s ) ;
}

std::string G::CodePage::fromCodePageAnsi( std::string_view s )
{
	using namespace G::CodePageImp ;
	if( s.empty() )
		return {} ;
	else if( G::is_windows() )
		return fromCodePageImp( CP_ACP , s , &fromCodePage1252 ) ;
	else
		return fromCodePage850( s ) ;
}

std::string G::CodePageImp::fromCodePageImp( unsigned int cp , std::string_view s ,
	std::string (*fallback_fn)(std::string_view) )
{
	int rc1 = MultiByteToWideChar( cp , WC_NO_BEST_FIT_CHARS ,
		s.data() , isize(s) ,
		nullptr , 0 ) ;
	if( rc1 <= 0 )
		return fallback_fn( s ) ;
	std::vector<wchar_t> buffer( sizet(rc1)+1U , L'\0' ) ;
	int rc2 = MultiByteToWideChar( cp , 0 ,
		s.data() , isize(s) ,
		dataout(buffer) , isize(buffer) ) ;
	if( rc1 != rc2 )
		return fallback_fn( s ) ;
	buffer.resize( sizet(rc1) ) ;
	return Convert::narrow( buffer.data() , buffer.size() ) ;
}

#if 0
#!/usr/bin/perl
use strict ;
use FileHandle ;
my @url = (
	[ "" , "https://www.unicode.org/Public/MAPPINGS/VENDORS/MISC/IBMGRAPH.TXT" ] ,
	[ "cp850" , "https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/PC/CP850.TXT" ] ,
	[ "cp8859_15" , "https://www.unicode.org/Public/MAPPINGS/ISO8859/8859-15.TXT" ] ,
	[ "cp1252" , "https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT" ] ,
	[ "cp1252_bestfit" , "https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit1252.txt" ] ,
) ;
my $extra = {} ;
for my $url_pair ( @url )
{
	my ( $name , $url ) = @{$url_pair} ;
	my $fh = new FileHandle( "wget -q -O - $url |" ) ;
	if( $name eq "" )
	{
		while(<$fh>)
		{
			chomp( my $line = $_ ) ;
			next if $line !~ m/^\d\d/ ;
			my ($uhex,$chex) = split( /\s/ , $line ) ;
			$extra->{hex("0x${chex}")} = "0x${uhex}" ;
		}
	}
	else
	{
		my $n = 0 ;
		print "\t\tconstexpr std::array<value_type,256> $name {{\n\t\t\t" ;
		while(<$fh>)
		{
			chomp( my $line = $_ ) ;
			my ($lhex,$rhex) = split( /\s/ , $line ) ;
			if( $lhex =~ m/^0x/ )
			{
				my $lvalue = hex($lhex) ;
				die if $lvalue != $n++ ;
				my $rvalue = hex($rhex) ;
				$rhex = "0xFFFF" if $rhex eq "" ;
				$rhex =~ tr/[a-f]/[A-F]/ ;
				if( $name eq "cp850" && exists($extra->{$lvalue}) ) { $rhex = $extra->{$lvalue} }
				print $rhex , ", " ;
				print "\n\t\t\t" if( ($n%16) == 0 ) ;
			}
			elsif( $lhex =~ m/WCTABLE/ ) # 1252 part two
			{
				last ;
			}
		}
		print "}} ;\n" ;
	}
}
#endif

